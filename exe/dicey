#!/usr/bin/env ruby
# frozen_string_literal: true

require "dicey"

module Dicey
  # Slice and dice everything in the Dicey module to produce a useful result.
  class Blender
    # Helper class for parsing command-line options and generating help.
    class Options
      require "optparse"

      # Allowed modes (--mode) (only directly selectable).
      MODES = %w[frequencies roll].freeze
      # Allowed result types (--result).
      RESULT_TYPES = %w[frequencies probabilities].freeze
      # Allowed output formats (--format).
      FORMATS = %w[list gnuplot json yaml].freeze

      # Default values for initial values of the options.
      DEFAULT_OPTIONS = { mode: "frequencies", format: "list", result: "frequencies" }.freeze

      def initialize(initial_options = DEFAULT_OPTIONS.dup)
        @options = initial_options
        @parser = OptionParser.new
        add_banner_and_version
        add_common_options
        add_test_options
        add_other_options
      end

      # Parse command-line arguments as options and return non-option arguments.
      #
      # @param argv [Array<String>]
      # @return [Array<String>] non-option arguments
      def read(argv)
        @parser.parse!(argv, into: @options)
      end

      # Get an option value by key.
      #
      # @param key [Symbol]
      # @return [Object]
      def [](key)
        @options[key]
      end

      # @return [Hash{Symbol => Object}]
      def to_h
        @options.dup
      end

      private

      def add_banner_and_version
        @parser.banner = <<~TEXT
          Usage: #{@parser.program_name} [options] <die> [<die> ...]
                 #{@parser.program_name} --test [full|quiet]
          All option names and arguments can be abbreviated if abbreviation is unambiguous.
        TEXT
        @parser.version = Dicey::VERSION
      end

      def add_common_options
        easy_option("-m", "--mode MODE", MODES, "What kind of action or calculation to perform.")
        easy_option("-r", "--result RESULT_TYPE", RESULT_TYPES,
                    "Select type of result to calculate (only for frequencies).")
        easy_option("-f", "--format FORMAT", FORMATS, "Select output format for results.")
      end

      def add_test_options
        @parser.on_tail(
          "--test [REPORT_STYLE]", %w[full quiet],
          "Check predefined calculation cases and exit.",
          "REPORT_STYLE can be: `full`, `quiet`.", "`full` is default."
        ) do |report_style|
          @options[:mode] = :test
          @options[:report_style] = report_style&.to_sym || :full
        end
      end

      def add_other_options
        @parser.on_tail("-h", "--help", "Show this help and exit.") do
          puts @parser.help
          exit
        end
        @parser.on_tail("-v", "--version", "Show program version and exit.") do
          puts @parser.ver
          exit
        end
      end

      def easy_option(short, long, values, description, &)
        values = values.keys if values.respond_to?(:keys)
        option_name = long[/[a-z_]+/].to_sym
        argument_name = long[/[A-Z_]+/]
        listed_values = "#{argument_name} can be: #{values.map { "`#{_1}`" }.join(", ")}."
        default_value = "`#{@options[option_name]}` is default." if @options[option_name]
        @parser.on(*[short, long, values, description, listed_values, default_value].compact, &)
      end
    end

    # List of calculators to use, ordered by efficiency.
    ROLL_FREQUENCY_CALCULATORS = [
      SumFrequencyCalculators::KroneckerSubstitution.new,
      SumFrequencyCalculators::MultinomialCoefficients.new,
      SumFrequencyCalculators::BruteForce.new,
    ].freeze

    # How to transform option values from command-line arguments to internally significant objects.
    OPTION_TRANSFORMATIONS = {
      mode: lambda(&:to_sym),
      result: lambda(&:to_sym),
      format: {
        "list" => OutputFormatters::ListFormatter.new,
        "gnuplot" => OutputFormatters::GnuplotFormatter.new,
        "yaml" => OutputFormatters::YAMLFormatter.new,
        "json" => OutputFormatters::JSONFormatter.new,
      }.freeze,
    }.freeze

    # What to run for every mode.
    # Every runner must respond to `call(arguments, **options)` and return true, false or String.
    RUNNERS = {
      roll: Roller.new,
      frequencies: SumFrequencyCalculators::Runner.new,
      test: SumFrequencyCalculators::TestRunner.new,
    }.freeze

    # Run the program, blending everything together.
    #
    # @option argv [Array<String>] arguments for the program
    # @return [Boolea, Object]
    # @raise [DiceyError] anything can happen
    def call(argv = ARGV)
      options, arguments = get_options_and_arguments(argv)
      require_optional_libraries(options)
      options[:roll_calculators] = ROLL_FREQUENCY_CALCULATORS
      return_value = RUNNERS[options.delete(:mode)].call(arguments, **options)
      print return_value if return_value.is_a?(String)
      !!return_value
    end

    private

    def get_options_and_arguments(argv)
      options = Options.new
      arguments = options.read(argv)
      options = options.to_h
      options.each_pair do |k, v|
        options[k] = OPTION_TRANSFORMATIONS[k][v] || v if OPTION_TRANSFORMATIONS[k]
      end
      [options, arguments]
    end

    # Require libraries only when needed, to cut on run time.
    def require_optional_libraries(options)
      case options[:format]
      when OutputFormatters::YAMLFormatter
        require "yaml"
      when OutputFormatters::JSONFormatter
        require "json"
      else
        # No additional libraries needed
      end
    end
  end
end

exit Dicey::Blender.new.call
